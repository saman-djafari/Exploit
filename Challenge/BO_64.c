//TO FIGURE OUT HOW LLVM CFI DEFINE .CFI FUNCTIONS 
//Once coment line 54--chained(input)--and get objdump to see the difference 
//the other time comment out line 63--branch2_start()--comapre the outputs of their objdump

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
typedef void (*fptr) (void);
void vulnfunc(char* input);

void function1 (void)
{
	printf("Indirect call of function1\n");
}

void function2 (void) {
	printf("Indirect call of function2\n");
}

void shell_execute(void)
{
	system("/bin/sh");
}
void vulnfunc(char * input)
{
	printf("vulfunc started!\n");
	fptr function;
	char buff[10];
	if (strcmp(input, "1") == 0)
		function = &function1;
	else
		function = &function2;
	printf("Input inside vulnfun is %s\n", input);
	strcpy(buff,input);
	function();
	printf("vulfunc finished!\n");
}
void chained(char * input){
	vulnfunc(input);
}
void directlyCalled(void){
	printf("Im directly called!");
}
void neverCalled(void){
	printf("%s\n", "Never Called!");
}
void anotherAdditional_BB_branch3(char * input, char * input2, char * input3){
	if(strcmp(input2, "1") == 0)
		printf("branch 3 1\n");
	else if(strcmp(input2, "2") == 0)
		printf("branch 3 2\n");
	else
		chained(input3);
}
void oneAdditional_BB_branch3(char * input, char * input2, char * input3){
	anotherAdditional_BB_branch3(input, input2, input3);
}
void sameType_with_shell(void){
	printf("just a simple function with the same signature as shell_execute");
}
void branch3_start(char * input, char * input2, char * input3){
	printf("branch 3\n");
	oneAdditional_BB_branch3(input, input2, input3);
}
void branch2_start(char * input){
	printf("branch 2\n");
}
void branch1_start(char * input){
	printf("branch 1\n");
	shell_execute();
}
void BB_after_main(char *argv[]){
	if(strcmp(argv[1],"1") == 0)
 		branch1_start(argv[1]);
 	else if(strcmp(argv[1],"2") == 0)
 		branch2_start(argv[1]);
 	else if(strcmp(argv[1],"3") == 0)
 		branch3_start(argv[1], argv[2], argv[3]);
}
int main(int argc, char *argv[])
{
 	if(argc <2)
 	{
    		printf("invalid input");
    		exit(1);
 	}
 	BB_after_main(argv);
	
	return 0;
}

